;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-advanced-reader.ss" "lang")((modname |2048|) (read-case-sensitive #t) (teachpacks ((lib "image.rkt" "teachpack" "2htdp") (lib "universe.rkt" "teachpack" "2htdp"))) (htdp-settings #(#t constructor repeating-decimal #t #t none #f ((lib "image.rkt" "teachpack" "2htdp") (lib "universe.rkt" "teachpack" "2htdp")))))
; This is a re-implementation of the game 2048 by Gabriele Cirulli
; for educational purposes by Klaus Ostermann, University of Marburg
; We also add a simple artificial intelligence player.

; For a big programming task like this, a pure top-down or bottom-up approach 
; is difficult. Instead we divide the task into program components, whereby
; a component is a coherent set of data type and function definitions.
; We describe the interface of each component first, whereby the interface
; consists of those data types and functions that are used by other components.
; Each component may have additional interal definitions. If we would use
; a _module systems_, we could put each componenet into a module and hide 
; those internal definitions. We will instead just assign a region of this
; file to each component.

; By fixing the interfaces of the components first, we can then implement each
; component in isolation (and already use the functions promised by the interfaces
; of other components). 
;
; In a bigger project, these componenents could be subdivided into subcomponents.
; Each component or subcomponent can then be implemented with top-down or
; bottom-up development (or a mix thereof).
;
; It is hard to get such interfaces right. During the implementation of the
; components, the interface should always be revised to reflect the latest
; state of knowledge. This is an instance of "incremental development":

; We divide the game into the following seven components:
; 1. Board representation
;      Types Cell, Row, Board, Direction
; 2. Game Logic
;      bump-board-up: Board -> Board
;      bump-board-down: Board -> Board
;      bump-board-left: Board -> Board
;      bump-board-right: Board -> Board
;      can-move: Board Direction -> Boolean
;      end-of-game: Board -> Boolean  
; 3. Addition of new cell at random location
;      insert-cell-at-random-pos:  Board Cell -> Board
; 4. Game Play
;      make-move: Board Direction -> Board
; 5. Graphical user interface
;      draw-board: Board -> Image
;      change: Board Key -> Board
; 6. Scoring
;      board-score: Board -> Number
; 7. AI
;      ai-next-move: Board -> Direction


; ********************
; Board Representation
; ********************

; A Cell is one of:
; - false
; - a number

; A Row is a (list-of Cell)
; A Board is a (list-of Row) where all rows have the same length

(define sampleboard '((1 #f 2) (#f #f #f) (#f 3 #f)))
(define INITIAL-BOARD '((#f #f 2 #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f)))
(define INITIAL-BOARD-4x4 '((#f #f 2 #f) (#f #f #f #f) (#f #f #f #f) (#f #f #f #f) ))

; A Direction is one of:
; - 'left
; - 'right
; - 'up
; - 'down

; ************************
; Game Logic and Game Play
; ************************

; The main game logic consists in bumping all numbers to one side
; Insight: It is sufficient if we implement bumping for one direction.
; The other directions will be dealt with by flipping and/or rotating the board.

; Row -> Row
; Moves all cells to the left and (left-associatively) merges adjacent cells of the same value
(check-expect (bump-row-left '(#f 1 #f 2 3 #f 4)) '(1 2 3 4 #f #f #f))
(check-expect (bump-row-left '(#f 2 #f 2 3 5 5 #f 5)) '(4 3 10 5 #f #f #f #f #f))
(check-expect (bump-row-left '(4 #f 4 #f 4 #f)) '(8 4 #f #f #f #f))
(check-expect (bump-row-left '(4 4 4 4)) '(8 8 #f #f))
(define (bump-row-left l) 
         ; Row (list-of False) -> Row
         ; the accumulator represents the list of false cells seen (or generated by doubling) so far
         ; Note: The function is implemented by generative recursion.
         ; We distinguish five cases:
  (local [(define (bump-row-left-acc l acc)
            (match l
               ; Case 1: the empty row. The answer is trivial: We returned the accumulated empty cells.
               [empty acc]  
               ; Case 2: Row starts with empty cell. We remind empty cells in the accumulator and move on.
               [(cons false xs) (bump-row-left-acc xs (cons false acc))] 
               ; Case 3: Row starts with number followed by empty cell. We remind the empty cell in the accumulator
               ; and remove the empty cell from the input
               [(cons x (cons false xs)) (bump-row-left-acc (cons x xs) (cons false acc))] 
               ; Case 4: Row starts with two numbers which are equal. Their value doubles and we generate a new empty cell.
               [(cons x (cons x xs)) (cons (* 2 x) (bump-row-left-acc xs (cons false acc)))]
               ; Case 5: In all other cases we do nothing with the first cell and continue with the remainder.
               [(cons x xs) (cons x (bump-row-left-acc xs acc))]))]
         ; Why does bump-row-left terminate? Because the length of l decreases in every recursive call.    
    (bump-row-left-acc l empty)))

; Board -> Board
; applies bump-row-left to all rows
(check-expect (bump-board-left '((1 #f 2) (#f #f #f) (#f 3 #f))) '((1 2 #f) (#f #f #f) (3 #f #f)))
(define (bump-board-left board) (map bump-row-left board))

; Row -> Row
; Moves all cells to the right and (right-associatively) merges adjacent cells of the same value
(check-expect (bump-row-right '(#f 1 #f 2 3 #f 4)) '(#f #f #f 1 2 3 4))
(define bump-row-right (compose reverse bump-row-left reverse))

; Board -> Board
; applies bump-row-right to all rows
(define (bump-board-right board) (map bump-row-right board))

; Board -> Board
; transposes the board
(check-expect (transpose '((1 2) (3 4))) '((1 3) (2 4)))
(define (transpose board)
  ; the function is implemented via generative recursion.
  ; Termination argument: The sum of the sizes of all lists
  ; decreases in the recursive call
  (if (empty? (first board))
      empty
      (cons 
       (map first board)
       (transpose (map rest board))))) ; generative recursion

; Board -> Board
(define bump-board-up (compose transpose bump-board-left transpose))

; Board -> Board
(define bump-board-down (compose transpose bump-board-right transpose))

; Board Direction -> Board
(define (bump-board board direction)
  (cond [(symbol=? direction 'left) (bump-board-left board)]
        [(symbol=? direction 'right) (bump-board-right board)]
        [(symbol=? direction 'up) (bump-board-up board)]
        [(symbol=? direction 'down) (bump-board-down board)]))

; Board Direction -> Boolean
; checks whether board can be moved in direction
; a board can be moved in a direction if something happens
(define (can-move board direction)
  (not (equal? board (bump-board board direction))))

; Board -> Boolean
; a game ends if no move is possible anymore
(define (end-of-game board)
  (not (or
        (can-move board 'left)
        (can-move board 'right)
        (can-move board 'up)
        (can-move board 'down))))

; ***************************************
; Addition of new cell at random location
; ***************************************

; Row -> Number
; the number of free cells in row
(define (free-cells-in-row row) (length (filter false? row)))

; Board -> Number
(check-expect (free-cells sampleboard) 6)
; the number of free cells in a board
(define (free-cells board)
  (apply + (map free-cells-in-row board)))

; Row -> Number -> Cell -> Row 
; replaces the num-th free cell in row by cell.
; The row is returned unchanged if the number of free cells is smaller than num 
(check-expect (replace-nth-free-row '(1 2 #f #f 3 #f 4) 2 77) '(1 2 #f #f 3 77 4))
(define (replace-nth-free-row row num cell)
  (match row 
    [empty empty]
    [(cons false xs) (if (zero? num)
                         (cons cell xs)
                         (cons false (replace-nth-free-row xs (sub1 num) cell)))]
    [(cons x xs) (cons x (replace-nth-free-row xs num cell))]))

; Board Number Cell -> Board
; replaces the num-th free cell in the board by cell.
; The free cells are counted left-to-right, top-to-bottom.
(check-expect (replace-nth-free-board sampleboard 4 77) '((1 #f 2) (#f #f #f) (77 3 #f)))
(define (replace-nth-free-board board num cell)
  (cond [(empty? board) empty]
        [(cons? board)
         (local [(define fcir (free-cells-in-row (first board)))]
           (if (<= fcir num)
               (cons (first board) (replace-nth-free-board (rest board) (- num fcir) cell))
               (cons (replace-nth-free-row (first board) num cell) (rest board))))]))

; Board Cell -> Board
; inserts cell at a random free cell in board
(define (insert-cell-at-random-pos board cell)
  (replace-nth-free-board board (random (free-cells board)) cell))

; **********
; Game Play
; **********

; the value of the cell that is inserted at random after every move
(define CELL-TO-BE-INSERTED 2)

; Board Direction -> Board
(define (make-move board direction)
  (if (can-move board direction)
      (insert-cell-at-random-pos
       (bump-board board direction)
       CELL-TO-BE-INSERTED)
      board))


; ******************************
; Graphical User Interface: View
; ******************************

(define CELL-SIZE 50)

; Cell -> Image
; renders a cell as an image
(define (draw-cell c)
  (if (false? c)
      (square CELL-SIZE "outline" "slateblue")
      (overlay
       (square CELL-SIZE "outline" "slateblue")
       (text (number->string c) (round (/ CELL-SIZE (if (>= c 1000) 3 2))) "black"))))

; Row -> Image
; renders a row as an image
(check-expect (image? (draw-row '(1 2 #f 3))) true)
(define (draw-row row) (apply beside (map draw-cell row)))

; Board -> Image
; renders a board as an image
(define (draw-board board) (apply above (map draw-row board)))

; ************************************
; Graphical User Interface: Controller
; ************************************

; Board Key -> Board
; translates a key stroke to an action on a board
(define (change w a-key)
  (cond
    [(key=? a-key "left")  (make-move w 'left)]
    [(key=? a-key "right") (make-move w 'right)]
    [(key=? a-key "up")    (make-move w 'up)]
    [(key=? a-key "down")  (make-move w 'down)]
    [else w]))

; *******
; Scoring
; *******

; Cell -> Number
; the score of a cell is determined by the accumulated collisions that must have caused the cell
(define (cell-score c)
  (if (false? c)
      0
      (* c (- (inexact->exact (/ (log c) (log 2))) 1) )))


; Board -> Number
; computes the score of a board
(check-expect (board-score '((2 #f 16) (4 64 8) (#f 128 #f))) 1156)
(define (board-score board)
  (apply + (map (lambda (r) (apply + (map cell-score r))) board)))

; ************************
; GUI Extension for Scores
; ************************

; Board -> Image
; draws the board together with current score
(check-expect (image? (draw-board-with-score sampleboard)) true)
(define (draw-board-with-score board)
  (above (draw-board board) 
         (text (string-append "Score: " (number->string (board-score board)))
               (/ CELL-SIZE 2)
               "red")))

; To play, we can start the game like this:
;(big-bang
; INITIAL-BOARD
; (on-key change)
; (to-draw draw-board-with-score)
; (stop-when end-of-game))


; *********
; AI Player
; *********

; Board -> Direction
; determines the next move according to the "greedy" heuristic that maximizes the score
(check-expect (ai-next-move '((4 8 8) (64 4 2) (64 8 2))) 'up) 
(define (ai-next-move board)
  (argmax 
   (lambda (d) (board-score (make-move board d))) 
   (filter (lambda (d) (can-move board d)) '(left right up down))))

(define (ai-game board)
  (big-bang
   board
   (on-tick (lambda (board) (make-move board (ai-next-move board))) 0.005)
   (to-draw draw-board-with-score)
   (stop-when end-of-game)))

; for instance, try
; (ai-game INITIAL-BOARD)